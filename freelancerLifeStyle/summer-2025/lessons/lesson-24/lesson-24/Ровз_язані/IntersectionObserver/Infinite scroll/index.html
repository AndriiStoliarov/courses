<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>IntersectionObserver Infinite Scroll with API</title>
    <style>
      body {
        font-family: sans-serif;
        margin: 0;
        padding: 20px;
      }
      #posts {
        list-style: none;
        padding: 0;
        margin: 0;
      }
      #posts li {
        padding: 15px;
        margin-bottom: 10px;
        border: 1px solid #ccc;
        background-color: #f9f9f9;
        font-size: 1.1em;
      }
      /* Стилі для індикатора завантаження */
      #loading-status {
        text-align: center;
        padding: 10px;
        font-weight: bold;
        color: #3498db;
      }
      /* Стилі для тригера */
      #load-trigger {
        height: 50px;
        text-align: center;
        line-height: 50px;
        margin-top: 20px;
        color: #777;
      }
    </style>
  </head>
  <body>
    <h1>Нескінченний Скрол (JSONPlaceholder API)</h1>
    <div id="loading-status">Натисніть F12, щоб побачити мережеві запити.</div>

    <div>
      <ul id="posts"></ul>
      <div id="load-trigger"></div>
    </div>

    <script>
      const list = document.querySelector('#posts')

      const trigger = document.querySelector('#load-trigger')

      const statusElement = document.querySelector('#loading-status')

      let page = 1
      const limit = 15 // Кількість постів на сторінку
      let isLoading = false // Запобігає одночасному виконанню кількох запитів

      // JSONPlaceholder містить лише 100 постів, тому ми матимемо 10 сторінок
      const API_URL = 'https://jsonplaceholder.typicode.com/posts'
      const MAX_PAGES = 10

      // --- ФУНКЦІЯ ЗАВАНТАЖЕННЯ ДАНИХ З API ---
      async function loadMore() {
        if (page > MAX_PAGES || isLoading) {
          if (page > MAX_PAGES) {
            statusElement.textContent = 'Усі 100 постів завантажено.'
            observer.unobserve(trigger) // Зупиняємо спостереження
          }
          return
        }

        isLoading = true
        statusElement.textContent = `Завантаження сторінки ${page}...`

        try {
          // Формуємо URL з параметрами пагінації
          const url = `${API_URL}?_page=${page}&_limit=${limit}`
          const res = await fetch(url)

          if (!res.ok) {
            throw new Error(`HTTP error! status: ${res.status}`)
          }

          const data = await res.json()

          if (data.length === 0) {
            // Якщо API повернуло порожній масив (досягнуто кінця даних)
            page = MAX_PAGES + 1
            statusElement.textContent = 'Усі дані завантажено.'
            observer.unobserve(trigger)
            return
          }

          // Додаємо дані до DOM
          data.forEach((item) => {
            const li = document.createElement('li')
            // Використовуємо заголовок (title) з API
            li.innerHTML = `<strong>${item.title}</strong><br><small>Post ID: ${item.id}</small>`
            list.appendChild(li)
          })

          page++ // Збільшуємо номер сторінки для наступного запиту
          statusElement.textContent = `Завантажено сторінку ${page - 1}.`
        } catch (error) {
          console.error('Помилка завантаження:', error)
          statusElement.textContent = `Помилка завантаження даних: ${error.message}`
        } finally {
          isLoading = false
        }
      }

      // --- IntersectionObserver ---
      const observer = new IntersectionObserver(
        async (entries) => {
          // Якщо елемент-тригер з'явився у полі зору
          if (entries[0].isIntersecting) {
            // Викликаємо функцію завантаження
            await loadMore()
          }
        },
        {
          // root: null (вікно браузера)
          // rootMargin: '0px 0px 200px 0px' - спрацює за 200px до того, як тригер потрапить у вікно
          rootMargin: '0px 0px 200px 0px',
          threshold: 0.01, // Спрацює, як тільки хоча б 1% елемента тригера видно
        }
      )

      // 1. Початкове завантаження, щоб сторінка не була порожньою
      loadMore()

      // 2. Починаємо спостереження за тригером
      // Це спрацює, коли завантажаться перші пости і тригер підніметься у поле зору
      observer.observe(trigger)
    </script>
  </body>
</html>
